<!DOCTYPE html>
<html>
<head>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: black; 
            transition: background-color 0.5s;
        }
        canvas { display: block; }
        
        .controls {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 100;
            display: flex;
            gap: 10px;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }
        
        .controls input[type="file"] {
            color: white;
            font-family: Arial;
            padding: 5px;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
            border: none;
        }

        .controls input[type="range"] {
            width: 200px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            -webkit-appearance: none;
        }

        .controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
        }

        .time-display {
            color: white;
            font-family: Arial;
            font-size: 14px;
            margin-left: 10px;
            min-width: 100px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <input type="file" id="audio-upload" accept="audio/*">
        <input type="range" id="seek-slider" min="0" max="100" value="0">
        <span class="time-display" id="time-display">0:00 / 0:00</span>
    </div>
    <canvas id="vibes-canvas"></canvas>
    <script>
        class ColorPalettes {
            constructor() {
                this.palettes = {
                    spring: [
                        {r: 255, g: 192, b: 203},
                        {r: 152, g: 251, b: 152},
                        {r: 173, g: 216, b: 230},
                        {r: 238, g: 221, b: 130},
                        {r: 221, g: 160, b: 221}
                    ],
                    summer: [
                        {r: 255, g: 69, b: 0},
                        {r: 0, g: 191, b: 255},
                        {r: 60, g: 179, b: 113},
                        {r: 255, g: 105, b: 180},
                        {r: 255, g: 255, b: 0}
                    ],
                    autumn: [
                        {r: 210, g: 105, b: 30},
                        {r: 255, g: 165, b: 0},
                        {r: 184, g: 134, b: 11},
                        {r: 139, g: 69, b: 19},
                        {r: 205, g: 133, b: 63}
                    ],
                    winter: [
                        {r: 176, g: 224, b: 230},
                        {r: 135, g: 206, b: 250},
                        {r: 169, g: 169, b: 169},
                        {r: 255, g: 250, b: 250},
                        {r: 0, g: 191, b: 255}
                    ]
                };
                this.currentPalette = 'spring';
                this.transitionSpeed = 0.005;
                this.currentIndex = 0;
                this.transitionProgress = 0;
            }

            lerpColor(color1, color2, factor) {
                return {
                    r: Math.round(color1.r + (color2.r - color1.r) * factor),
                    g: Math.round(color1.g + (color2.g - color1.g) * factor),
                    b: Math.round(color1.b + (color2.b - color1.b) * factor)
                };
            }

            getColors(time) {
                const palette = this.palettes[this.currentPalette];
                const colors = [];
                
                // Плавный переход между цветами
                for(let i = 0; i < palette.length; i++) {
                    const timeOffset = time * 0.5 + (i / palette.length) * Math.PI * 2;
                    const factor = (Math.sin(timeOffset) + 1) / 2;
                    
                    const color1 = palette[i];
                    const color2 = palette[(i + 1) % palette.length];
                    colors.push(this.lerpColor(color1, color2, factor));
                }
                
                return colors;
            }

            nextPalette() {
                const palettes = Object.keys(this.palettes);
                const currentIndex = palettes.indexOf(this.currentPalette);
                this.currentPalette = palettes[(currentIndex + 1) % palettes.length];
            }
        }

        class LiquidMass {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.points = [];
                this.layers = 8;
                this.pointsPerLayer = 180;
                this.centerX = canvas.width / 2;
                this.centerY = canvas.height / 2;
                this.time = 0;
                this.smoothedAudioData = new Array(32).fill(0);
                this.colorPalettes = new ColorPalettes();
                this.smoothingFactor = 0.8;
                this.baseSize = Math.min(canvas.width, canvas.height) * 0.3;
                this.lastAverageColor = {r: 0, g: 0, b: 0};
                this.initPoints();
            }

            initPoints() {
                this.points = [];
                for(let layer = 0; layer < this.layers; layer++) {
                    let layerPoints = [];
                    for(let i = 0; i < this.pointsPerLayer; i++) {
                        const angle = (i / this.pointsPerLayer) * Math.PI * 2;
                        layerPoints.push({
                            baseAngle: angle,
                            angle: angle,
                            radius: this.baseSize * (0.3 + layer * 0.15),
                            baseRadius: this.baseSize * (0.3 + layer * 0.15),
                            x: 0,
                            y: 0,
                            vx: 0,
                            vy: 0,
                            noise: Math.random() * 0.8
                        });
                    }
                    this.points.push(layerPoints);
                }
            }

            calculateAverageColor(colors) {
                const avg = colors.reduce((acc, color) => ({
                    r: acc.r + color.r,
                    g: acc.g + color.g,
                    b: acc.b + color.b
                }), {r: 0, g: 0, b: 0});

                return {
                    r: Math.round(avg.r / colors.length),
                    g: Math.round(avg.g / colors.length),
                    b: Math.round(avg.b / colors.length)
                };
            }

            updatePoints(frequencyData) {
                this.time += 0.01;
                
                for(let i = 0; i < frequencyData.length; i++) {
                    this.smoothedAudioData[i] = this.smoothedAudioData[i] * 0.7 + 
                                              frequencyData[i] * 0.3;
                }

                const maxFreq = Math.max(...this.smoothedAudioData);
                const audioScale = maxFreq / 255;
                
                this.points.forEach((layer, layerIndex) => {
                    const layerFactor = 1 - (layerIndex / this.layers);
                    
                    layer.forEach((point, index) => {
                        const freqIndex = Math.floor((index / this.pointsPerLayer) * 32);
                        const freq = this.smoothedAudioData[freqIndex] / 255;
                        
                        const timeScale = 1 + layerIndex * 0.1;
                        const wave1 = Math.sin(this.time * timeScale + point.baseAngle * 3) * 15;
                        const wave2 = Math.cos(this.time * 0.7 * timeScale + point.baseAngle * 2) * 12;
                        const wave3 = Math.sin(this.time * 1.3 * timeScale + point.baseAngle * 4 + point.noise) * 10;
                        
                        const audioEffect = freq * 120 * layerFactor;
                        
                        point.radius = point.baseRadius + wave1 + wave2 + wave3 + audioEffect;
                        
                        const targetX = this.centerX + Math.cos(point.angle) * point.radius;
                        const targetY = this.centerY + Math.sin(point.angle) * point.radius;
                        
                        point.x = point.x * 0.85 + targetX * 0.15;
                        point.y = point.y * 0.85 + targetY * 0.15;
                    });
                });
            }

            draw() {
                const colors = this.colorPalettes.getColors(this.time);
                this.lastAverageColor = this.calculateAverageColor(colors);
                
                document.body.style.backgroundColor = `rgb(${Math.round(this.lastAverageColor.r * 0.15)}, 
                                                         ${Math.round(this.lastAverageColor.g * 0.15)}, 
                                                         ${Math.round(this.lastAverageColor.b * 0.15)})`;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                for(let i = this.layers - 1; i >= 0; i--) {
                    const layer = this.points[i];
                    const alpha = 0.8 - (i * 0.07);
                    
                    const gradient = this.ctx.createRadialGradient(
                        this.centerX, this.centerY, 0,
                        this.centerX, this.centerY, layer[0].baseRadius * 1.5
                    );

                    const color1 = colors[i % colors.length];
                    const color2 = colors[(i + 1) % colors.length];
                    
                    gradient.addColorStop(0, `rgba(${color1.r}, ${color1.g}, ${color1.b}, ${alpha})`);
                    gradient.addColorStop(1, `rgba(${color2.r}, ${color2.g}, ${color2.b}, ${alpha * 0.5})`);

                    this.ctx.beginPath();
                    
                    layer.forEach((point, index) => {
                        const nextPoint = layer[(index + 1) % layer.length];
                        const prevPoint = layer[(index - 1 + layer.length) % layer.length];
                        
                        if (index === 0) {
                            const lastPoint = layer[layer.length - 1];
                            this.ctx.moveTo((lastPoint.x + point.x) / 2, (lastPoint.y + point.y) / 2);
                        }
                        
                        const cp1x = point.x + (nextPoint.x - prevPoint.x) * 0.15; // Уменьшили с 0.2 до 0.15
                        const cp1y = point.y + (nextPoint.y - prevPoint.y) * 0.15;
                        const cp2x = nextPoint.x - (nextPoint.x - point.x) * 0.15;
                        const cp2y = nextPoint.y - (nextPoint.y - point.y) * 0.15;
                        
                        this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, nextPoint.x, nextPoint.y);
                    });

                    this.ctx.closePath();
                    this.ctx.fillStyle = gradient;
                    
                    this.ctx.shadowBlur = 30;
                    this.ctx.shadowColor = `rgba(${color1.r}, ${color1.g}, ${color1.b}, 0.5)`;
                    this.ctx.fill();
                }

                const glowGradient = this.ctx.createRadialGradient(
                    this.centerX, this.centerY, 0,
                    this.centerX, this.centerY, this.baseSize
                );
                
                const glowColor = colors[0];
                glowGradient.addColorStop(0, `rgba(${glowColor.r}, ${glowColor.g}, ${glowColor.b}, 0.3)`);
                glowGradient.addColorStop(0.5, `rgba(${glowColor.r}, ${glowColor.g}, ${glowColor.b}, 0.15)`);
                glowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                this.ctx.fillStyle = glowGradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
        }

        class AudioVisualizer {
            constructor(canvas) {
                this.canvas = canvas;
                this.liquidMass = new LiquidMass(canvas);
                this.audioContext = null;
                this.analyser = null;
                this.audioSource = null;
                this.dataArray = null;
                this.isPlaying = false;
                this.currentTime = 0;
                this.duration = 0;
                this.timeUpdateInterval = null;
                
                this.seekSlider = document.getElementById('seek-slider');
                this.timeDisplay = document.getElementById('time-display');
                
                this.setupEventListeners();
                this.animate = this.animate.bind(this);
            }

            setupEventListeners() {
                this.seekSlider.addEventListener('input', (e) => {
                    if (this.audioSource) {
                        const time = (this.duration * e.target.value) / 100;
                        this.audioContext.currentTime = time;
                        this.updateTimeDisplay(time);
                    }
                });

                // Обработка пробела для паузы/воспроизведения
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && this.audioSource) {
                        if (this.isPlaying) {
                            this.audioContext.suspend();
                        } else {
                            this.audioContext.resume();
                        }
                        this.isPlaying = !this.isPlaying;
                        e.preventDefault();
                    }
                });
            }

            formatTime(seconds) {
                const minutes = Math.floor(seconds / 60);
                seconds = Math.floor(seconds % 60);
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            updateTimeDisplay(currentTime) {
                if (this.duration) {
                    this.timeDisplay.textContent = 
                        `${this.formatTime(currentTime)} / ${this.formatTime(this.duration)}`;
                    this.seekSlider.value = (currentTime / this.duration) * 100;
                }
            }

            setupAudio(arrayBuffer) {
                if (this.audioContext) {
                    this.audioContext.close();
                }
                
                // Очищаем предыдущий интервал, если он существует
                if (this.timeUpdateInterval) {
                    clearInterval(this.timeUpdateInterval);
                }
                
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.audioContext.decodeAudioData(arrayBuffer, (buffer) => {
                    this.duration = buffer.duration;
                    
                    this.audioSource = this.audioContext.createBufferSource();
                    this.audioSource.buffer = buffer;
                    
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 64;
                    
                    this.audioSource.connect(this.analyser);
                    this.analyser.connect(this.audioContext.destination);
                    
                    this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                    
                    this.audioSource.start(0);
                    this.isPlaying = true;
                    
                    // Добавляем обработчик окончания воспроизведения
                    this.audioSource.onended = () => {
                        this.isPlaying = false;
                        clearInterval(this.timeUpdateInterval);
                        this.updateTimeDisplay(this.duration); // Устанавливаем конечное время
                    };
                    
                    // Сохраняем ссылку на интервал
                    this.timeUpdateInterval = setInterval(() => {
                        if (this.isPlaying) {
                            this.currentTime = this.audioContext.currentTime;
                            this.updateTimeDisplay(this.currentTime);
                        }
                    }, 100);
                });
            }

            animate() {
                // Получаем частотные данные
                if (this.analyser) {
                    this.analyser.getByteFrequencyData(this.dataArray);
                }

                // Обновляем и рисуем визуализацию
                this.liquidMass.updatePoints(this.dataArray || new Uint8Array(32));
                this.liquidMass.draw();

                requestAnimationFrame(this.animate);
            }
        }

        // Инициализация
        const canvas = document.getElementById('vibes-canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const visualizer = new AudioVisualizer(canvas);
        visualizer.animate();

        // Обработка изменения размера окна
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            visualizer.liquidMass = new LiquidMass(canvas);
        });

        // Обработка загрузки аудио
        document.getElementById('audio-upload').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    visualizer.setupAudio(e.target.result);
                };
                reader.readAsArrayBuffer(file);
            }
        });
    </script>
</body>
</html>